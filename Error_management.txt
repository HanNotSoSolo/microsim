*** INTRODUCTION
Ce fichier n'est pas là pour rester, car probablement je trouverai une meilleure façon d'exprimer ceci. Ce fichier est un bloc notes personnel, qui me sert à tenir compte des erreurs que je trouves et comment les résoudre "à la volée", mais le mieux serait encore de faire en sorte, dans le programme, qu'elles ne se produisent pas. On va traiter ça comme une sorte de WikiBugs.

*** LISTE D'ERREURS

** IndexError: index XXX is out of bounds for axis 0 with size XXX
Elle est généralement produite lors de solver.solve(), dans un module de Sfepy, à la ligne 37 de sfepy/discrete/fem/mesh.py, lors de la résolution avec la méthode des éléments finis inversée. C'est généralement le signe que quelque chose ne va pas avec les domaines, et pour autant que j'en ait compris c'est du au fait que le nombre de noeuds sur la surface de coupure est inégal entre le domaine interne et externe. Ce n'est pas une erreur de Femtoscope, mais elle vient de l'utilisateur (bien que je sois incapable d'en déterminer les causes) et de ses fichiers géométriques.
* RÉSOLUTION: reprendre le fichier géométrique et s'assurer que, lors de la création d'une ligne ou d'une courbe (comme lors de la création du domaine interne ou externe, s'il est circulaire), il n'y a pas de signes "-": en effet, il est écrit dans le manuel de Gmsh qu'une boucle ("Loop") peut se faire en prenant l'opposée d'une ligne/courbe, pour prendre la ligne qui va du point 2 au point 1 au lieu que la ligne qui va du point 1 au point 2; or, j'ai observé que l'erreur en question apparait (aussi?) quand il y a des signes "-" dans la création d'une boucle, et disparait quand il n'y en a pas. Je serais, à ce stade, incapable d'expliquer pourquoi ou quel impact ça a sur le fichier de maillage VTK.

** ValueError: warp violation!
Produite là aussi lors du solver.solve(), elle intervient généralement de la même façon que l'erreur ci-dessus mais disparait dès qu'on fait un Restart Kernel. Les deux erreurs sont très liées: lorsque une résolution aboutit et le programme s'arrête, et on modifie le script GEO en ajoutant des signes "-" là où il ne faut pas (voir erreur précédente), et qu'on relance une simulation, c'est généralement cette erreur qui apparait: elle continuera de nous hanter jusqu'au redémarrage du kernel, pour laisser la place à IndexError. Il est indéniable à présent que des données restent en mémoire entre une résolution et l'autre.
* RÉSOLUTION: tout comme l'erreur précédente, elle est liée au fichier géométrique. Elle est généralement résolue en se débarrassant des signes "-" lors de la création d'une boucle de lignes/courbes.

** Exception "Could not get last error"
C'est une exception de Gmsh qui est appelée lors de l'initialisation de l'API Python par Femtoscope, à coup sur dans le module Meshfactory. C'est le signe que Gmsh n'arrive pas à s'initialiser, et c'est une erreur bloquante si l'on veut modifier un fichier géométrique pour lancer une simulation. Gmsh (externe) peut tout à fait très bien marcher à l'exterieur de Femtoscope alors que l'API Python non.
* RÉSOLUTION: l'erreur et sa solution sont postés sur https://gitlab.onelab.info/gmsh/gmsh/-/issues/3380. Pour faire simple, lors de l'initialisation de Gmsh dans femtoscope/inout/meshfactory.py, à la ligne 102, il faut ajouter ReadConfgFiles=False dans gmsh.initialize(), car cette variable est vraie par défaut. Dans les nouvelles versions de Gmsh (post 4.15) ce problème devrait être résolu.

** ValueError: operands could not be broadcast together with shapes (XXX,) (XXX,)
Cette erreur générique indique que les deux vecteurs sur lesquels on essaye de faire une opération ont des tailles différentes, ou pour le moins incompatibles. Ce n'est pas une erreur de Femtoscope, car Python ne fait qu'appliquer les règles mathématiques.
RÉSOLUTION: Je laisse ça ici juste car cette erreur m'est déjà arrivée, mais comme c'est une erreur générale de Python elle doit être résolue au cas par cas, en changeant le script pour faire en sorte que les vecteurs soient cohérents entre eux. L'erreur m'est apparue lors du post-processing, dans param.set_data(), alors que j'essayais de multiplier deux vecteurs à priori issus du même fichier de résultat. En réalité, l'erreur se trouvait dans la fonction de résolution, car j'avais inséré le mauvais nom du fichier à retourner. En gros: une typo, et j'espère vraiment que les prochaines erreurs seront aussi simples à trouver.

** Perte de précision soudaine du calcul
Ceci est un problème nouveau, que je ne comprends pas encore. Le résultat est précis, puis pour une raison quelconque je veux en faire un autre (donc une autre étape de résolution), et là le nouveau calcul est moins précis. Si l'on redémarre le noyeau, le résultat est à nouveau le bon. Impossible de trop comprendre pourquoi ça arrive. Il doit y avoir une fuite de mémoire ou d'une variable quelque part...
